<?php
/**
 * developed by www.g-u-i.net
 * 2011
 * First time this field will be used, it will create a new term with the value inserted in the textfield, 
 * after that, the term (tid) will always be the same, just update term name by updating the value of the field. 
 * You can keep synchronized a fixe term with a node, 
 * you can set an auto title from this field, The required, 
 * number of value at 1 and term_node synch of global field are required
 * 
 * <?php 
 * // automatic node titles php snippet for translation
 * $items = field_get_items('node', $node, 'field_tode_program');
 * return t($items[0]['name']);
 * ?>
 *
 * 
 */



/**
 * Implements hook_views_api().
 */
/*
	TODO hook_views_api().
*/
// function tode_views_api() {
//   return array(
//     'api' => 3,
//     'path' => drupal_get_path('module', 'tode') . '/views',
//   );
// }



/**
 * Implementation of hook_theme().
 */
function tode_theme() {
	return array(
		'tode' => array(
			'arguments' => array('element' => NULL),
		),
	);
}

/**
 * Implementation of hook_init().
 */
function tode_init() {
	// File hooks and callbacks may be used by any module.
	drupal_add_css(drupal_get_path('module', 'tode') .'/tode.css');
}

/**
 * Implementation of hook_field_widget_info().
 */
function tode_field_widget_info() {
	
	return array(
    'tode' => array(
      'label' => t('Tode (create then update one unique term)'),
      'field types' => array('taxonomy_term_reference'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
				'default value' => FIELD_BEHAVIOR_NONE,
      ),
      'settings' => array(
        'size' => 60,
				'show_term_form'=> -1,
				'choose_term_parent'=> -1,
				'maxlength'=> 255,
      ),
    ),
  );
}

/**
 * Implementation of hook_widget_settings
 */
function tode_field_widget_settings_form($field, $instance){
	// dsm($instance, 'tode_field_widget_settings_form : $instance');
	// dsm($field, 'field');
	
	$widget = $instance['widget'];
  $settings = $widget['settings'];

	
		// '#description' => t('First time this field will be used, it will create a new term with the value inserted in the textfield, after that, the term (tid) will always be the same, just update term name by updating the value of the field. You can keep synchronized a fixe term with a node, you can set an auto title from this field, The required, number of value at 1 and term_node synch of global field are required')
		 
		$form['maxlength'] = array(
			'#type' => 'textfield', 
			'#title' => t('Maximum length of term'), 
			'#default_value' => $settings['maxlength'],
			'#element_validate' => array('_tode_widget_settings_maxlength_validate'),
			'#required' => TRUE,
			'#description' => t('Defines how many characters can be typed into the text field. For values higher than 255, remember that one term name can not be longer than 255 (would be cutted).'),
		);
		
		/*
			TODO complete the all flow of this
		*/
		$form['show_term_form'] = array(
			'#type' => 'checkbox',
			'#title' => t('Show taxonomy term edit form ?'),
			'#default_value' => $settings['show_term_form'],
		);

		$form['choose_term_parent'] = array(
			'#type' => 'checkbox',
			'#title' => t('Enable taxonomy term parent selection ?'),
			'#default_value' => $settings['choose_term_parent'],
		);

		$form['redirect_term_to_node'] = array(
			'#type' => 'checkbox',
			'#title' => t('Rewrite all term link to theire tode node ?'),
			'#default_value' => $settings['redirect_term_to_node'],
		);

		$form['show_create_tode'] = array(
			'#type' => 'checkbox',
			'#title' => t('Show create "tode" on term fields about this tode\'s vocabulary ?'),
			'#default_value' => $settings['show_create_tode'],
		);
		
		return $form;
}

function _tode_widget_settings_maxlength_validate($element, &$form_state) {
	// dsm('_tode_widget_settings_maxlength_validate');
	// dsm($element, '$element');
	// dsm($form_state, '$form_state');
	$widget = $form_state['values']['instance']['widget'];
	$value = $widget['settings']['maxlength'];
	if (!is_numeric($value) || intval($value) != $value || $value <= 0) {
		form_error($element, t('"Maximum length" must be a positive integer.'));
	}
}

/**
 * Implementation of FAPI hook_elements().
 *
 * Any FAPI callbacks needed for individual widgets can be declared here,
 * and the element will be passed to those callbacks for processing.
 *
 * Drupal will automatically theme the element using a theme with
 * the same name as the hook_elements key.
 *
 * Autocomplete_path is not used by text_widget but other widgets can use it
 * (see nodereference and userreference).
 * 
 * http://drupal.org/node/224333#hook_element_info
 * 
 */
#hook_element_info() WHY ??
/*
function tode_element_info(){
	return array(
	 'tode' => array(
		 '#input' => TRUE,
		 '#columns' => array('value'), 
		 '#delta' => 0,
		 '#process' => array('tode_element_process'),
		 ),
	 );
}
*/

/**
 * Implementation of hook_field_widget_form().
 */
function tode_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
	// dsm('- - - - tode_field_widget_form');
	// dsm($form, '&$form');
	// dsm($form_state, '&$form_state');
	// dsm($items, 'items');
	// dsm($element, '$element');
	// dsm($field, '$field');
	// dsm($instance, '$instance');

	
	if(isset($form_state['node'])){
		$language = $form_state['node']->language;
	}else{
		$language = null;
	}
	// dsm($node, '$node');
	
	if(isset($items[$delta])){
		$term = taxonomy_term_load($items[$delta]['tid']);
		// $term = i18n_taxonomy_term_get_translation($term, $node->language); // marche pas avec localized term
		// dsm($term, '$term');
		$term_parents = taxonomy_get_parents($term->tid);
		// dsm($term_parents, '$term_parents');
		$term_parent = array_pop($term_parents);
	}
	
	# no need of $node->translation_source because with node translation (not entity fields translation) tid remains
	# just have to translate term name on submit
	// if( !isset($node->id) && isset($node->translation_source) ){
	// }
	
	$form['tode_tid'] = array('#type' => 'hidden', '#value' => isset($term) ? $term->tid : 0,'#delta' => $element['#delta'],);
	
	# parent
	if( $instance['widget']['settings']['choose_term_parent'] ){
		// add parent form autocomplete if activated		
		$vocabularies = array();
    foreach ($field['settings']['allowed_values'] as $tree)
      if ($vocabulary = taxonomy_vocabulary_machine_name_load($tree['vocabulary']))
        $vocabularies[$vocabulary->vid] = $vocabulary;

    $vocabulary = reset($vocabularies);
		// dsm($vocabulary, '$vocabulary');
		
		$form['tode_vid'] = array('#type' => 'hidden', '#value' => $vocabulary->vid,'#delta' => $element['#delta'],);
		
		$form['tode_parent_term'] = array(
			'#title' => 'Parent ' . $vocabulary->name,
	    '#type' => 'textfield',
	    '#default_value' => isset($term_parent) ? $term_parent->name : '',
	    '#autocomplete_path' => 'taxonomy/autocomplete' . '/' . $field['field_name'],
	    '#size' => 60,
	    '#maxlength' => 1024,
	    '#element_validate' => array('tode_parent_autocomplete_validate'),
	  );
	
	}else{
		// if parent selection not enabled set the current parent as hidden input
		$form['tode_parent_term'] = array(
		  '#type' => 'hidden',
		  '#value' => isset($term_parent) ? $term_parent->name : '',
			'#delta' => $element['#delta'],
		);
	}
	
	// set element form item
  $element += array(
    '#type' => 'textfield',
    '#default_value' => isset($term) ? ( module_exists('i18n_taxonomy') ? i18n_taxonomy_term_name($term, $language) : $term->name ) : '',
    '#size' => $instance['widget']['settings']['size'],
    '#maxlength' => $instance['widget']['settings']['maxlength'],
    '#element_validate' => array('tode_widget_validate'),
    // '#element_submit' => array('tode_widget_submit'),
  );
	

	# add the term edit form
	if(isset($term))
		_tode_add_term_form($form, $term, $instance, $element['#delta']);
	
	// dsm($form, 'end tode_field_widget_form :: $form');
  return $element;
}


/**
 * _tode_add_term_form($term)
 *
 * show the complete taxonomy term form if feature is enabled
 * 
 */
function _tode_add_term_form(&$form, $term, $instance, $delta){
	// dsm('- - - - _tode_add_term_form');
	module_load_include('inc', 'taxonomy', 'taxonomy.admin');
	
	$term_form = _tode_term_form($term);
	// dsm($term_form, 'term_form');
	
	if($term_form){

		unset($term_form['actions']);
		unset($term_form['#action']);
		unset($term_form['#method']);
		
		#unset vid info 'cause is in conflict with the node's vid field
		unset($term_form['vid']);
		
		$term_form = _tode_clean_form($term_form);

		$prefix = 'tode_termform_'.$instance['field_name'];
		$term_form = _tode_prefix_form($term_form, $prefix.'_');

		$visible = $instance['widget']['settings']['show_term_form'];
				
		$form[$prefix] = array(
			'#type' => 'fieldset',
			'#title' => t('Term edit'),
			'#tree' => TRUE,
			'#collapsible' => TRUE,
			'#collapsed' => FALSE,
			'#weight'=>1,
			// '#group'=>'additional_settings',
			'#prefix' => $visible ? null : '<div style="display:none;">',
			'#suffix' => $visible ? null : '</div>',
		);
				  
		$form[$prefix] += $term_form;


		
		// $form['tode_termform'] = array('#type' => 'hidden', '#value' => 'true','#delta' => $delta,);
		
	}

}


/**
 * Form element validate handler for tode parent term autocomplete element.
 */
function tode_parent_autocomplete_validate($element, &$form_state) {
	// dsm('- - - - tode_autocomplete_validate');
	// dsm($element, '$element');
	// dsm($form_state, '$form_state');

	$value = array();
  if ($typed_term = $element['#value']) {  
   	// Translate term names into actual terms.
    // See if the term exists in the chosen vocabulary and return the tid;
    // otherwise, set error.
    if ($possibilities = taxonomy_term_load_multiple(array(), array('name' => trim($typed_term), 'vid' => $form_state['values']['tode_vid']))) {
      $term = array_pop($possibilities);
			$value = (array)$term;
    }
    else {
		form_error($element, t('Parent term can only be an existing term.'));
    }
  }
  // 
	// dsm('form_set_value');
  form_set_value($element, $value, $form_state);
}

/**
 * Validation function for the tode element
 *
 * parses input and sets the values as needed (tid) for storing the data
 */
function tode_widget_validate($element, &$form_state){
	// dsm('- - - - tode_widget_validate');
	// dsm($form_state, 'form_state');
	// dsm($element, 'element');
	
	// $node = $form_state['node'];
	
	
 	$value = array();
  if ($typed_term = $element['#value']) {
		$field = field_widget_field($element, $form_state);
		// dsm($field, 'field');

    $vocabularies = array();
    foreach ($field['settings']['allowed_values'] as $tree) {
      if ($vocabulary = taxonomy_vocabulary_machine_name_load($tree['vocabulary'])) {
        $vocabularies[$vocabulary->vid] = $vocabulary;
      }
    }
		
		// get the parent term tid or 0 (no parents)
		$parent_tid = isset($form_state['values']['tode_parent_term']['tid']) ? $form_state['values']['tode_parent_term']['tid'] : 0;
		
		// See if the term already exists and load the term
    // otherwise, create a new 'autocreate' term for insert.
		if($tid = $form_state['values']['tode_tid']){
			$term = taxonomy_term_load($tid);
			
			$term->name = $typed_term;
			$term->parent = $parent_tid;
			
		}else{
			$vocabulary = reset($vocabularies);
			$term = (object)array(
        'tid' => 'autocreate', // autocreate not needed with direct taxonomy_term_save [EDIT] autocreate needed because of the hook_submit insted of hook_validate 
        'vid' => $vocabulary->vid,
        'name' => $typed_term,
        'vocabulary_machine_name' => $vocabulary->machine_name,
				'parent' => $parent_tid,
      );
			// taxonomy_term_save($term); // save here the new term to directly get the tid on hook_node_validate
			// [EDIT] do not save the term here because it will be save even if node form is not validate
			// results term without node or mutiple orfan term
			// moving all process on node submit
			
		}
		
		// dsm($term, '$term');
		$value = (array)$term;
	}
	
	// dsm($value, '$value');
  form_set_value($element, $value, $form_state);
}


/**
 * Implements hook_field_widget_error().
 */
function tode_field_widget_error($element, $error, $form, &$form_state) {
	# use this to set errors
	form_error($element['value'], $error['message']);
}


/**
 * Implements hook_node_submit().
 */
function tode_node_submit($node, $form, &$form_state) {
	// dsm('- - - tode_node_submit');
	// dsm($node, '$node');
	// dsm($form, '$form');
	// dsm($form_state, '$form_state');

	
	module_load_include('inc', 'taxonomy', 'taxonomy.admin');
	// module_load_include('inc', 'i18n_string', 'i18n_string.pages');
	// 
	$tode_fields = _tode_get_node_tode_fields_def($node);
	// dsm($tode_fields, '$tode_fields');
	
	
	if(!count($tode_fields))
		return;
	
	$language = $node->language;

	$default_language = language_default('language');
	// dsm($default_language, '$default_language');
	
	foreach ($tode_fields as $field_name => $field) {

		// retreive the prefixed termfom values (hidden or visible)
		$prefix = 'tode_termform_'.$field_name;
		
		// if term_form is not available
		// it meens that we are on the creation of a node
		// hook_node_presave will handle this case
		if( !isset($form_state['values'][$prefix]) )
			continue;
		
		// else
		// we are on the update or on the translation (from initial node)
		// so we can go forward
		
		// retreive the initial tode_field language
		$init_language = $form[$field_name]['#language'];

		// retreive the value of term field, to get the typed term name
		if(isset($form_state['values'][$field_name][$init_language][0])){
			$tode_field_term_value = $form_state['values'][$field_name][$init_language][0];			
		}else if(isset($form_state['values'][$field_name][$language][0])){
			$tode_field_term_value = $form_state['values'][$field_name][$language][0];			
		}else if(isset($form_state['values'][$field_name]['und'][0])){
			$tode_field_term_value = $form_state['values'][$field_name]['und'][0];			
		}else{
			drupal_set_message('$form_state[values][$field_name][$language][0] is undefined', 'warning');
			$tode_field_term_value = false;
		}

		// dsm($tode_field_term_value, '$tode_field_term_value');
		if($tode_field_term_value){
			// dsm($form_state['values'][$prefix], '$form_state["values"][$prefix]');
			$values = _tode_prefix_form($form_state['values'][$prefix], $prefix.'_', FALSE);
			// dsm($values, 'values');

			if(module_exists('i18n_taxonomy') && $language != 'und' && $language != $default_language){
				$context= array('term',$values['tid'],'name');

				i18n_string_textgroup('taxonomy')->update_translation($context, $language, $tode_field_term_value['name']);
				
				$tode_field_term_value['name'] = $values['name'];
			}


			$parent_tid = $tode_field_term_value['parent'];
			$values['parent'] = array($parent_tid => $parent_tid);
			
			
			
			// if(!module_exists('i18n_taxonomy') || $language == 'und' || $language == $default_language){

			// define the form_state for term_form submit
			$new_term_form_state = array(
				'build_info'=>array(
					'args'=>array(0=>(object)$tode_field_term_value),
				),
				"values"=>array(
					'name'=> $tode_field_term_value['name'], // replace the original (hidden) term name value by the typed in the the entity field
					'op'=> t('Save'),
				)
			);
			// add new values to form_state
			$new_term_form_state['values'] += $values;

			// dsm($new_term_form_state, 'form_state');
			drupal_form_submit('taxonomy_form_term', $new_term_form_state);
			// }else{			
				
			
		}
		
	}
	
}



/**
 * Implements hook_node_presave().
 */
function tode_node_presave($node) {
	// dsm('- - - tode_node_presave');
	// dsm($node, 'node');
	
	if($node->nid)
		return;
	
	$tode_fields = _tode_get_node_tode_fields_def($node);
	
	if(!count($tode_fields))
		return;
	
	$default_language = language_default('language');

	// purpose of that is to directly atribute the right language to the term	
	foreach ($tode_fields as $field_name => $field){
		$tode_field = $node->$field_name;
		$tode_field_term = $tode_field[$node->language][0]; // on node creation field language is always to und (sure ?)

		// // test the language, if not default language create the term name translation
		if( module_exists('i18n_taxonomy') && ( $node->language != 'und' || $node->language != $default_language ) ){
			$context= array('term',$tode_field_term['tid'],'name');
			i18n_string_textgroup('taxonomy')->update_translation($context, $node->language, $tode_field_term['name']);
		}
		
	}
}


/*
	TODO  merge two terms when translation is made by selecting a node whiche already exists
*/

/*
	TODO create a node when a term is created else where than the node which got the tode
*/

/**
 * Implements hook_menu().
 */
function tode_menu() {
	// dsm('tode_menu');
	$items = array();
	
	$items['tode/%ctools_js/add'] = array(
	  'title' => 'Tode modal add entity',
	  'page callback' => 'tode_entity_add',
	  'page arguments' => array(1,3,4,5),
		'access callback' => TRUE,
		'type' => MENU_CALLBACK,
	);
	
	return $items;
}

function tode_entity_add($js = FALSE, $bundle, $entity, $title = 'Title'){
	
  // Fall back if $js is not set.
  if (!$js) {
    return drupal_get_form('tode_entity_add_form', $bundle, $entity);
  }

  ctools_include('modal');
  ctools_include('ajax');
  $form_state = array(
    'title' => t('Create '.$entity),
    'ajax' => TRUE,
    'build_info' => array('args' => array('0' => $bundle, '1' => $entity, '2' => $title)),
  );
  $output = ctools_modal_form_wrapper('tode_entity_add_form', $form_state);

  if (!empty($form_state['executed'])) {
    $commands = array();
    $commands[] = ctools_modal_command_dismiss();
    print ajax_render($commands);
    exit;
  }
  else {
    print ajax_render($output);
    exit;
  }
	
	
}

function tode_entity_add_form($form, $form_state, $bundle, $entity, $title) {
	
	$form = array();
	$form['title'] = array(
	  '#type' => 'textfield',
	  '#title' => t($title),
	  '#size' => 40,
	  '#maxlength' => 255,
	);
	$form['bundle'] = array(
	  '#type' => 'hidden',
	  '#value' => $bundle,
	);
	$form['entity'] = array(
	  '#type' => 'hidden',
	  '#value' => $entity,
	);
	
	$form['create'] = array(
	  '#type' => 'submit',
	  '#value' => t('Create'),
	);
	
	return $form;
}

function tode_entity_add_form_validate($form, &$form_state){

  if(empty($form_state['values']['title'])){
    form_set_error('title', 'Title field can\'t be empty!');
  }
	
}

function tode_entity_add_form_submit($form, &$form_state){
	global $user;
	// dsm($form_state, '$form_state');
	$values = $form_state['values'];
	$bundle_fields = field_info_instances($values['bundle']);
	// dsm($bundle_fields, '$bundle_fields');
	
	$fields = $bundle_fields[$values['entity']];
	// dsm($fields, '$fields');
	
	foreach ($fields as $field_name => $field) {
		if($field['widget']['type'] == 'tode'){
			$tode_field = $field;
			break;
		}
	}
	
	# get vocabulary
	$tode_field_infos = field_info_field($field['field_name']);
	// dsm($tode_field_infos, '$tode_field_infos');
	$voc_name = $tode_field_infos['settings']['allowed_values'][0]['vocabulary'];
	$vocabulary = taxonomy_vocabulary_machine_name_load($voc_name);
	// dsm($vocabulary, '$vocabulary');
	
	# create the term
	$term = new stdClass();
	$term->name = $values['title'];
	$term->vid = $vocabulary->vid; // ‘1’ is a vocabulary id you wish this term to assign to
	// $term->field_custom_field_name[LANGUAGE_NONE][0]['value'] = ‘Some value’; // OPTIONAL. If your term has a custom field attached it can added as simple as this
	taxonomy_term_save($term); // Finally, save our term
	// dsm($term, '$term');
	
	# create the node
	//http://www.group42.ca/creating_and_updating_nodes_programmatically_in_drupal_7
	//http://timonweb.com/how-programmatically-create-nodes-comments-and-taxonomies-drupal-7
	$node = new stdClass();
  $node->type = $values['entity'];
  node_object_prepare($node);
	$tode_field_name = $tode_field['field_name'];
	$node = (array)$node +array(
		"title" => $values['title'],
		"language" => LANGUAGE_NONE,
		"uid" => $user->uid,
		$tode_field_name => array( LANGUAGE_NONE => array(0 => array('tid' => $term->tid))),
	);
	
	
//	$node->$tode_field_name[$node->language]['tid'] = $term->tid;
		// $node->$tode_field_name = array( $node->language => array('tid' => $term->tid));
	
	// $tode_field_name = $tode_field['field_name'];
	// $node = (object) array(
	//   	"type" => $values['entity'],
	//   // node_object_prepare($node);
	//  		"title"	=> $values['title'],
	// 	"language" => LANGUAGE_NONE,
	// 	"uid" => $user->uid,
	// 	$tode_field_name => array( LANGUAGE_NONE=>array('tid' => $term->tid)),
	// );
	$node = (object)$node;
	
	// dsm($node, '$node');
	node_save($node);
	// dsm($node, '$node');

	
	# tag the node with the term
	
	# set the tode field to the term tid
	

}



function BAD_ONE_tode_entity_add_form($js = FALSE, $bundle, $entity) {
	// dsm('- - - - tode_entity_add_form');
	//   dsm($bundle, '$bundle');
	//   dsm($entity, '$entity');
	
	// error_log($js);
	// error_log($bundle);
	// error_log($entity);
	// 
		
	global $user;

	//module_load_include('inc', 'node', 'node.pages');
	ctools_include('node.pages', 'node', '');

	$node = (object) array(
		'uid' => $user->uid, 
		'name' => (isset($user->name) ? $user->name : ''), 
		'type' => $entity, 
		'language' => LANGUAGE_NONE
	);
	
	$form_id = $entity.'_node_form';
	
	if (!$js) {
		return drupal_get_form($form_id, $node);
	}
	
	ctools_include('modal');
	ctools_include('ajax');
	
	$form_state = array(
		'title' => t('Add '.$entity),
		'ajax' => TRUE,
	);
	
	$form_state['build_info']['args'] = array($node);

	$output = ctools_modal_form_wrapper($entity.'_node_form', $form_state);

	if (!empty($form_state['executed'])) {
		$output = array();
		$output[] = ctools_modal_command_display( t('Node created'), '<div class="modal-message">'.$entity.' creation successful.</div>'); /** Add success message*/
	};

	print ajax_render($output);
	exit;
}



/**
 * Implements hook_field_widget_form_alter().
 * 
 * add create entity bundle front of term reference field with tode voc
 */
function DESACTIVATED_tode_field_widget_form_alter(&$element, &$form_state, $context) {
	$field = $context['field'];
	$instance = $context['instance'];

	if($field['type'] == 'taxonomy_term_reference' && ($instance['widget']['type'] == 'taxonomy_autocomplete' || $instance['widget']['type'] == 'autocomplete_deluxe_taxonomy')){
//		dsm('- - - - - tode_field_widget_form_alter');
		 // dsm($element, '$element');
		 // dsm($form_state, '$form_state');
		 // dsm($context, '$context');
		// dsm($instance['widget']['type'], '$instance[widget][type]');
		
		foreach ($field['settings']['allowed_values'] as $key => $value) {
				
			if($tode = _tode_get_voc_tode_fields_def($value['vocabulary'])){

				ctools_include('ajax');
		    ctools_include('modal');
		    ctools_modal_add_js();
		
				// ctools_add_css('tode', 'tode');
				// drupal_add_css(drupal_get_path('module', 'tode') . "tode.css");
				// dsm($tode, '$tode');
				$type_fields = field_info_instances('node');


				if(!isset($element['#attributes']["class"]))
					$element['#attributes']["class"] = array();
					
				$element['#attributes']["class"][] = "tode-add-modal";
				
				$element['#suffix'] = '';				
				foreach ($tode['bundles'] as $bundle => $entities) {
					foreach ($entities as $entity) {
						$tode_instance = $type_fields[$entity][$tode['field_name']];
						
						$btn = ctools_modal_text_button(t('create a new %s', array('%s'=>$entity)), 'tode/nojs/add/'.$bundle.'/'.$entity.'/'.$tode_instance['label'], t('alt'), "button ctools-modal-tode-add-modal") . "\n"; // modal-popup-small
						// $btn .= ctools_modal_text_button(t('create new test'), 'tode/nojs/add/node/test', t('alt'));
					// dsm($btn);
						if($element['#suffix'] == '')
							$element['#suffix'] = '<div class="tode-add-modal-links">';
							
						$element['#suffix'] .= $btn;
					}
				}
			}
		}
		
		if( isset($element['#suffix']) && $element['#suffix'] != '' ){
			
  		$throbber = theme('image', array('path' => ctools_image_path('loading_animation.gif', 'modal_forms'), 'alt' => t('Loading...'), 'title' => t('Loading')));
			$js_settings = array(
		    'tode-add-modal' => array(
		      'modalSize' => array(
		        'type' => 'fixed',
		        'width' => 500,
		        'height' => 200,
		      ),
		      'modalOptions' => array(
		        'opacity' => 0.4,
		        'background' => '#000',
		      ),
		      'animation' => 'fadeIn',
		      // 'modalTheme' => 'ModalFormsPopup',
		      'throbber' => $throbber,
		      'closeText' => t('Close'),
		    ),
		  );
			
		  drupal_add_js($js_settings, 'setting');
			
			$element['#prefix'] = '<div class="tode-add-modal-wrapper">';
			$element['#suffix'] .= '</div></div>';
		}
		
				 // dsm($element, '$element');
		
	}
}

/**
 * Implements hook_taxonomy_term_insert().
 */
// function tode_taxonomy_term_insert($term) {
// 	dsm($term, '$term');
// }



/**
 * Implementation of hook_form_alter().
 * 
 * node deletion to delete also the tode term
 * 
 */
function tode_form_alter(&$form, $form_state, $form_id){
		// dsm($form_id, 'tode form_alter form_id');	
	/*
		TODO block the deletion if tode term has children !! because this will delete them to …
	*/
	if($form_id == 'test_node_form'){
		// dsm($form_state);
	}
	if (stripos($form_id, 'node_delete_confirm') !== false){
		// dsm($form_id, 'tode form_alter form_id');
		_tode_node_delete_form_alter($form, $form_state);
		// dsm($form);
	}else if(stripos($form_id, 'node_admin_content') !== false){
		if(isset($form['operation']) && $form['operation']['#value'] == 'delete'){
			// dsm($form, 'node_admin_content form');
			// dsm($form_state, 'form_state');
			_tode_nodes_delete_form_alter($form, $form_state);

		}
	}

}

function _tode_node_delete_form_alter(&$form, $form_state){
	// dsm($form, '_tode_node_delete_form_alter : form');
	// get the node
	$node = $form['#node'];
	// dsm($node, '$node');

	#get the fields defenition of node type
	$tode_fields = _tode_get_node_tode_fields_def($node);
	// dsm($tode_fields);
	
	if(count($tode_fields) == 0)
		return;

	#get the terms value
	$terms = array('names'=>array(), 'tids'=>array());
	foreach ($tode_fields as $field_name => $field)
		_tode_populate_terms_node_delete($terms, $node->$field_name);

	_tode_node_delete_prepare_form($form, $terms);
}

function _tode_nodes_delete_form_alter(&$form, $form_state){
	// dsm($form, '_tode_nodes_delete_form_alter : form');
	$nodes = array();
	foreach ($form_state['values']['nodes'] as $nid => $actif)
		if($actif)
			$nodes[] = node_load($nid);

	#get the terms value
	$terms = array('names'=>array(), 'tids'=>array());
	foreach ($nodes as $node) {
		#get the fields definition of node type
		$tode_fields = _tode_get_node_tode_fields_def($node);
		//dsm($tode_fields);
		
		if(count($tode_fields) == 0)
			continue;

		foreach ($tode_fields as $field_name => $field)
			_tode_populate_terms_node_delete($terms, $node->$field_name);
			
	}

	_tode_node_delete_prepare_form($form, $terms);
}

function _tode_populate_terms_node_delete(&$terms, $tode_field){
	foreach ($tode_field as $language) {
		foreach ($language as $term) {
			$term = taxonomy_term_load($term['tid']);
			if(isset($term->tid) && !in_array($term->tid, $terms['tids'])){
				$terms['names'][] = $term->name;
				$terms['tids'][] = $term->tid;
			}
		}
	}
}

function _tode_node_delete_prepare_form(&$form, $terms){

	if(count($terms)){
		/*
			TODO add here a checkbox to select terms to delete
		*/
		#add some warning in form description
		$form['description']['#markup'] .= '<br />'.t('this will also delete taxonomy terms : %terms', array('%terms'=>implode(', ', $terms['names'])));

		$form['tode_delete'] = array( '#type' => 'hidden', '#value' => serialize($terms['tids']),);

		$form['tode_terms'] = array('#type' => 'hidden', '#value' => serialize($terms['names']),);

		$form['#submit'][] = 'tode_delete_submit';
	}
	
	
}

function tode_delete_submit($form, &$form_state){
	$tids = unserialize($form['tode_delete']['#value']);
	foreach ($tids as $tid)
		taxonomy_term_delete($tid);
		
	$terms = unserialize($form['tode_terms']['#value']);	
	drupal_set_message(t('Following Taxonomy terms have been deleted : %terms', array('%terms' => implode(', ', $terms) )), 'status');
}


/**
 * Implements hook_url_outbound_alter().
 */
function tode_url_outbound_alter(&$path, &$options, $original_path) {
	
	# terms url
	$term = false;
	if(isset($options['entity_type']) && $options['entity_type'] == 'taxonomy_term'){
		// dsm('- - - - tode_url_outbound_alter');
		// dsm($path, '$path');
		// dsm($options, '$options');
		// dsm($original_path, '$original_path');
		
		$term = $options['entity'];

  }else{
		$args = explode('/', $original_path);
		// dsm($args, 'args');
		if($args[0] == 'taxonomy' && $args[1] == 'term' && is_numeric($args[2]) ){
			$term = taxonomy_term_load($args[2]);			
		}

	}
	
	if($term){
		// dsm($term, '$term');
		if($field = _tode_get_voc_tode_fields_def($term->vocabulary_machine_name)){
			# add if widget setting;
			if (isset($field['widget']['settings']['redirect_term_to_node'])  && $field['widget']['settings']['redirect_term_to_node']) {
				// dsm($field, '$field');
				// dsm($options, '$options');
				$sr = $field['storage']['details']['sql']['FIELD_LOAD_CURRENT'];
				foreach ($sr as $table => $column) {
					$query = db_select($table, 'ft');
					$query->join('node', 'n', 'ft.entity_id = n.nid AND n.language = :language OR n.language = :language', array(':language' => $options['language']->language, ':language' => 'und'));
					$query
					  ->fields('ft')
					  ->condition('ft.'.$column['tid'], $term->tid);
					$result = $query->execute();
					break;
				}

				foreach ($result as $node) {
					// dsm($node, '$node');
					$new_path = 'node/'.$node->entity_id;
					if( $new_alias = drupal_get_path_alias($new_path, $options['language']->language) ){
						$path = $new_alias;
						$original_path = $new_path;
						$options['alias'] = TRUE;
					}else{
						$path = $new_path;
					}
					break;
				}
			}
		
		}

	}
}

/**
 * HELPERS 
 */
function _tode_clean_form($form, $level = 0){
	foreach ($form as $key => $value) {
		if(strpos($key,'#') !== false || $key == 'form_build_id' || $key == 'form_id' || $key == 'form_token'){
			if( $level == 0 || $key == "#element_validate")
				unset($form[$key]);
		}elseif(is_array($value)){
			$form[$key] = _tode_clean_form($value, $level+1);			
		}
	}
	return $form;
}

function _tode_prefix_form($form, $prefix = '', $add = TRUE){
	
	foreach ($form as $key => $value) {
		if(strpos($key,'#') === false){

			if((isset($value['#type']) && $value['#type'] == 'fieldset') || (!$add && is_array($value)))
				$value = _tode_prefix_form($value, $prefix, $add);
				
			if($add){
				$form[$prefix.$key] = $value;
				unset($form[$key]);
			}elseif(strpos($key, $prefix) !== false ){
				$form[str_replace($prefix, '', $key)] = $value;
				unset($form[$key]);
			}
			
		}
	}
	
	return $form;
}

/**
 * _tode_term_form($tid)
 * 
 */
function _tode_term_form($term){
	// dsm('_tode_term_form');
	if ($term) {
		
		$form_state = array(
			'build_info'=>array(
				'args'=>array(0=>$term)
			),
			'method'=>'post',
		);

		// function taxonomy_form_term($form, &$form_state, $edit = array(), $vocabulary = NULL) {
		$term_form = drupal_retrieve_form('taxonomy_form_term', $form_state);
		drupal_prepare_form('taxonomy_form_term', $term_form, $form_state);
		
		return $term_form;
	}else{
		return false;
	}
	
}

/**
 * _tode_trim_options(&$form, $element)
 * 
 */
function _tode_trim_options(&$form, $item){
	foreach ($form[$item] as $field_name => $field) {
		if(((is_array($field)) && $field['#type'] == 'select') && $field['#multiple']){
			$options = $field['#options'];
			for ($i=0; $i < count($options); $i++) { 
				if(!isset($options[$i]->option)) 
					continue;
					
				$op = array();
				foreach ($options[$i]->option as $key => $value)
						$op[$key] = strlen($value) > 25 ? substr_replace ($value, ' [...] ', 15, -10) : $value; // affiche 'abc...xyz'
						
				$options[$i]->option = $op;
			}
			$field['#options'] = $options;
			$form[$item][$field_name] = $field;
		}
	}
}

/**
 * _tode_get_node_tode_fields_def
 */
function _tode_get_node_tode_fields_def($node){
	// dsm($node, '_tode_get_fields_def');

	#get the fields defenition of node type
	$type_fields = field_info_instances('node');
	// dsm($type_fields, 'type_fields definition');

	#get the tode node fields
	$tode_fields = array();
	foreach ($type_fields[$node->type] as $field_name => $field) {
		if($field['widget']['type'] == 'tode')
			$tode_fields[$field_name] = $field;
	}


	return $tode_fields;
}

function _tode_get_voc_tode_fields_def($voc_name){
	$type_fields = field_info_instances('node');
	// dsm($type_fields, '$type_fields');
	foreach ($type_fields as $nodetype => $fields)
		foreach ($fields as $field_name => $field)
			if($field['widget']['type'] == 'tode'){
				$fieldinfos = field_info_field($field_name);
				if($voc_name == $fieldinfos['settings']['allowed_values'][0]['vocabulary'])
					return $fieldinfos;
			}
				
	
	return false;
	
}

function tode_get_nids_from_term($term, $language = false){
	$todefield = _tode_get_voc_tode_fields_def($term->vocabulary_machine_name);

	if($todefield){
		$query = new EntityFieldQuery();
		$query->entityCondition('entity_type', 'node')
		->fieldCondition($todefield['field_name'], 'tid', $term->tid);
		
		if($language)
			$query->propertyCondition('language', array('und', $language), 'IN');
			
		$result = $query->execute();
		if(count($result))
			return $result;
	}
	
	return false;
}



