<?php
/**
 * developed by www.g-u-i.net
 * 2011
 * First time this field will be used, it will create a new term with the value inserted in the textfield, 
 * after that, the term (tid) will always be the same, just update term name by updating the value of the field. 
 * You can keep synchronized a fixe term with a node, 
 * you can set an auto title from this field, The required, 
 * number of value at 1 and term_node synch of global field are required
 * 
 * 
 */

/**
 * Implementation of hook_menu().
 */
/*
function tode_menu() {
	$items = array();

	// $items['node/%node/tode/%term'] = array(
	//     'title' => 'Taxonomy Term',
	//     'type' => MENU_LOCAL_TASK,
	//     'access callback' => 'tode_node_tab_access',
	//     'access arguments' => array(2),
	//     'page callback' => 'tode_tab_page',
	//     'page arguments' => array(2),
	//     'file' => 'tode.pages.inc',
	//     'weight' => 2,
	//   );

	return $items;
}
*/

/**
 * Implementation of hook_theme().
 */
function tode_theme() {
	return array(
		'tode' => array(
			'arguments' => array('element' => NULL),
		),
	);
}

/**
 * Implementation of hook_init().
 */
function tode_init() {
	// File hooks and callbacks may be used by any module.
	drupal_add_css(drupal_get_path('module', 'tode') .'/tode.css');
}

/**
 * Implementation of hook_field_widget_info().
 */
# BUG PLUS
function tode_field_widget_info() {
	
	return array(
    'tode' => array(
      'label' => t('Tode (create then update one unique term)'),
      'field types' => array('taxonomy_term_reference'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
				'default value' => FIELD_BEHAVIOR_NONE,
      ),
      'settings' => array(
        'size' => 60,
				'show_term_form'=> -1,
				'choose_term_parent'=> -1,
				'maxlength'=> 255,
      ),
    ),
  );
}

/**
 * Implementation of hook_widget_settings
 */
#hook_field_widget_settings_form($field, $instance)
function tode_field_widget_settings_form($field, $instance){
	dsm($instance, 'tode_field_widget_settings_form : $instance');
	dsm($field, 'field');
	
	$widget = $instance['widget'];
  $settings = $widget['settings'];

	
		// '#description' => t('First time this field will be used, it will create a new term with the value inserted in the textfield, after that, the term (tid) will always be the same, just update term name by updating the value of the field. You can keep synchronized a fixe term with a node, you can set an auto title from this field, The required, number of value at 1 and term_node synch of global field are required')
		 
		$form['maxlength'] = array(
			'#type' => 'textfield', 
			'#title' => t('Maximum length of term'), 
			'#default_value' => $settings['maxlength'],
			'#element_validate' => array('_tode_widget_settings_maxlength_validate'),
			'#required' => TRUE,
			'#description' => t('Defines how many characters can be typed into the text field. For values higher than 255, remember that one term name can not be longer than 255 (would be cutted).'),
		);
		
		/*
			TODO complete the all flow of this
		*/
		// $form['show_term_form'] = array(
		// 	'#type' => 'checkbox',
		// 	'#title' => t('Show taxonomy term edit form ?'),
		// 	'#default_value' => $settings['show_term_form'],
		// );

		$form['choose_term_parent'] = array(
			'#type' => 'checkbox',
			'#title' => t('Enable taxonomy term parent selection ?'),
			'#default_value' => $settings['choose_term_parent'],
		);

		return $form;
	
}

function _tode_widget_settings_maxlength_validate($element, &$form_state) {
	// dsm('_tode_widget_settings_maxlength_validate');
	// dsm($element, '$element');
	// dsm($form_state, '$form_state');
	$widget = $form_state['values']['instance']['widget'];
	$value = $widget['settings']['maxlength'];
	if (!is_numeric($value) || intval($value) != $value || $value <= 0) {
		form_error($element, t('"Maximum length" must be a positive integer.'));
	}
}

/**
 * Implementation of FAPI hook_elements().
 *
 * Any FAPI callbacks needed for individual widgets can be declared here,
 * and the element will be passed to those callbacks for processing.
 *
 * Drupal will automatically theme the element using a theme with
 * the same name as the hook_elements key.
 *
 * Autocomplete_path is not used by text_widget but other widgets can use it
 * (see nodereference and userreference).
 * 
 * http://drupal.org/node/224333#hook_element_info
 * 
 */
#hook_element_info() WHY ??
/*
function tode_element_info() {
	return array(
	 'tode' => array(
		 '#input' => TRUE,
		 '#columns' => array('value'), 
		 '#delta' => 0,
		 '#process' => array('tode_element_process'),
		 ),
	 );
}
*/

/**
 * Implementation of hook_field_widget_form().
 */
function tode_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
	// dsm('tode_field_widget_form');
	// dsm($form, '&$form');
	// dsm($form_state, '&$form_state');
	// dsm($items, 'items');
	// dsm($element, '$element');
	// dsm($field, '$field');
	// dsm($instance, '$instance');

	if(isset($items[$delta])){
		$term = taxonomy_term_load($items[$delta]['tid']);
		// dsm($term, '$term');
		$term_parents = taxonomy_get_parents($term->tid);
		dsm($term_parents, '$term_parents');
		$term_parent = array_pop($term_parents);
	}
	
	$form['tode_tid'] = array('#type' => 'hidden', '#value' => isset($term) ? $term->tid : 0,'#delta' => $element['#delta'],);


	// add parent form autocomplete if activated
	if($instance['widget']['settings']['choose_term_parent']){
		
		$vocabularies = array();

    foreach ($field['settings']['allowed_values'] as $tree)
      if ($vocabulary = taxonomy_vocabulary_machine_name_load($tree['vocabulary']))
        $vocabularies[$vocabulary->vid] = $vocabulary;

    $vocabulary = reset($vocabularies);
		// dsm($vocabulary, '$vocabulary');
		
		$form['tode_vid'] = array('#type' => 'hidden', '#value' => $vocabulary->vid,'#delta' => $element['#delta'],);
		
		$form['tode_parent_term'] = array(
			'#title' => 'Parent ' . $vocabulary->name . ' (optional)',
	    '#type' => 'textfield',
	    '#default_value' => isset($term_parent) ? $term_parent->name : '',
	    '#autocomplete_path' => 'taxonomy/autocomplete' . '/' . $field['field_name'],
	    '#size' => 60,
	    '#maxlength' => 1024,
	    '#element_validate' => array('tode_autocomplete_validate'),
	  );
	
	}
	
	// set element form item
  $element += array(
    '#type' => 'textfield',
    '#default_value' => isset($term) ? $term->name : '',
    '#size' => $instance['widget']['settings']['size'],
    '#maxlength' => $instance['widget']['settings']['maxlength'],
    '#element_validate' => array('tode_validate'),
  );
	


	# add the term edit form
	// if($term_tid)
	// 	_tode_add_term_form($element, $term, $instance['widget']['settings']['show_term_form']);
	
	// dsm($element, '$element');
  return $element;
}


/**
 * _tode_add_term_form($term)
 *
 * show the complete taxonomy term form if feature is enabled
 * 
 */
# note available yet with 7.x
function _tode_add_term_form(&$element, $term, $show){
	module_load_include('inc', 'taxonomy', 'taxonomy.admin');
	
	$term_form = _tode_term_form($term);
	dsm($term_form, 'term_form');
	
	if($term_form){
		// 
		// $term_form['identification']['#prefix'] = '<div style="display:none;">';
		// $term_form['identification']['#suffix'] = '</div>';
		// $term_form['advanced']['synonyms']['#prefix'] = '<div style="display:none;">';
		// $term_form['advanced']['synonyms']['#suffix'] = '</div>';
		// $term_form['advanced']['weight']['#prefix'] = '<div style="display:none;">';
		// $term_form['advanced']['weight']['#suffix'] = '</div>';
		// $term_form['advanced']['parent']['#prefix'] = '<div style="display:none;">';
		// $term_form['advanced']['parent']['#suffix'] = '</div>';
		// $term_form['advanced']['relations']['#prefix'] = '<div style="display:none;">';
		// $term_form['advanced']['relations']['#suffix'] = '</div>';
		// 
		// # change appearence of adavnced fiedset to show both fiedlset inline
		// $term_form['advanced']['#collapsible'] = FALSE;
		// $term_form['fields']['#collapsible'] = FALSE;
		// 
		// _tode_trim_options($term_form, 'advanced');
		// $term_form['advanced']['#attributes'] = array('class'=>'tcu-advanced-options');
		// $term_form['fields']['#attributes'] = array('class'=>'tcu-term-fields');
		// 
		// foreach($term_form['fields'] as $field_name => $field){
		// 	if($field['#type'] == 'textfield')
		// 		$field['#size'] = 30;
		// 		
		// 	$term_form['fields'][$field_name] = $field;
		// }
		// 
		// unset($term_form['submit']);
		// unset($term_form['delete']);
		// 
		// #unset vid info 'cause is in conflict with the node's vid field
		// // unset($term_form['vid']);

		$element['term_form'] = array(
			'#type' => 'fieldset',
			'#title' => t('Term edit'),
			'#tree' => TRUE,
			'#collapsible' => TRUE,
			'#collapsed' => FALSE,
			'#weight'=>1,
			'#group'=>'additional_settings',
		);
		
		// if(!$show){
		// 	$element['term_form']['#prefix'] = '<div style="display:none;">';
		// 	$element['term_form']['#suffix'] = '</div>';
		// }

		$term_form = _tode_prefix_form($term_form, 'tode_termform_'.$element['#field_name'].'_');

		$element['term_form'] += $term_form;
		
		$element['tode_termform'] = array('#type' => 'hidden', '#value' => 'true','#delta' => $element['#delta'],);
		
		// $element['#prefix'] = '<div class="tode-term-edit-form-box">';
		// $element['#suffix'] = '</div>';

		dsm($element, 'element');
	}

}


/**
 * Form element validate handler for tode parent term autocomplete element.
 */
function tode_autocomplete_validate($element, &$form_state) {
	// dsm('tode_autocomplete_validate');
	// dsm($element, '$element');
	// dsm($form_state, '$form_state');

	$value = null;
  if ($typed_term = $element['#value']) {  
   	// Translate term names into actual terms.
    // See if the term exists in the chosen vocabulary and return the tid;
    // otherwise, set error.
    if ($possibilities = taxonomy_term_load_multiple(array(), array('name' => trim($typed_term), 'vid' => $form_state['values']['tode_vid']))) {
      $term = array_pop($possibilities);
			$value = (array)$term;
    }
    else {
		form_error($element, t('Parent term can only be an existing term.'));
    }
  }
  // 
  form_set_value($element, $value, $form_state);
}

/**
 * Validation function for the tode element
 *
 * parses input and sets the values as needed (tid) for storing the data
 */
function tode_validate($element, &$form_state){
	// dsm('tode_validate');
	// dsm($form_state, 'form_state');
	// dsm($element, 'element');

	/*
		TODO term translation (entity translate + node title question)
	*/
	
 	$value = array();
  if ($typed_term = $element['#value']) {
		$field = field_widget_field($element, $form_state);
		// dsm($field, 'field');

    $vocabularies = array();
    foreach ($field['settings']['allowed_values'] as $tree) {
      if ($vocabulary = taxonomy_vocabulary_machine_name_load($tree['vocabulary'])) {
        $vocabularies[$vocabulary->vid] = $vocabulary;
      }
    }
		
		// See if the term already exists and load the term
    // otherwise, create a new 'autocreate' term for insert.
		if($tid = $form_state['values']['tode_tid']){
			$term = taxonomy_term_load($tid);
		}else{
			$vocabulary = reset($vocabularies);
			$term = array(
        'tid' => 'autocreate',
        'vid' => $vocabulary->vid,
        'name' => $typed_term,
        'vocabulary_machine_name' => $vocabulary->machine_name,
      );
		}
		
		// save the parent term if provided
		if($parent_term = $form_state['values']['tode_parent_term']){
			dsm($parent_term, 'tode_parent_term');
			$term->parent = $parent_term['tid'];
			taxonomy_term_save($term);
		}
		
		// dsm($term, '$term');
		
		$value = (array)$term;
	
	}
	// dsm($value, '$value');
  form_set_value($element, $value, $form_state);
}

/**
 * Implements hook_field_widget_error().
 */
function tode_field_widget_error($element, $error, $form, &$form_state) {
	# use this to set errors
	form_error($element['value'], $error['message']);
}

/**
 * Implements hook_node_validate().
 *
 * use to save the all term form (steel have to be debuged)
 *
 */
function __tode_node_validate($node, $form){
	
	module_load_include('inc', 'taxonomy', 'taxonomy.admin');
	
 	dsm('tode_node_validate');
 	dsm($node, '&node');
	dsm($form, '&form');

	$tode_fields = _tode_get_tode_fields_def($node);
	dsm($tode_fields, '$tode_fields');
	
	#	OK
	
	/*	
	if(!count($tode_fields))
		return;
		
	foreach ($tode_fields as $field_name => $field) {
		$values = array();
		$prefix = 'tode_termform_'.$field_name.'_';
		foreach ($node as $key => $value) {
			if(strpos($key, $prefix) !== FALSE)
				$values[$key] = $value;
		}
		// dsm($values, 'values');
		$values = _tode_prefix_form($values, $prefix, FALSE);
		// dsm($values, 'values');
		
		$array_term = (array)taxonomy_get_term($values['tid']);
		
		foreach ($values as $key => $value) {
			if(is_array($value))
				$values += $value;
		}
		
		$array_term = (array)taxonomy_get_term($values['tid']);
		
		// dsm($values, 'values');
		
		$form_state = array();
		$form_state['values']	= $values;
		$form_state['values']['op'] = t('Save');
		
		// dsm($form_state, 'form_state');
			  
		drupal_execute('taxonomy_form_term', $form_state, taxonomy_vocabulary_load($array_term['vid']), $array_term);
		
	}
	*/
}

/**
 * theme_tode
 * 
 */
// function theme_tode($element) {
// 	dsm('theme_tode');
// 	dsm($element, '$element');
// 	return $element['#children'];
// }


/**
 * Implementation of hook_form_alter().
 * 
 * node deletion to delete also the tode term
 * 
 */
function tode_form_alter(&$form, $form_state, $form_id){
	
	if (stripos($form_id, 'node_delete_confirm') !== false){
		// dsm($form_id, 'tode form_alter form_id');
		/*
			TODO test deletion
		*/
		_tode_node_delete_form_alter($form, $form_state);
		// dsm($form);
	}

}

function _tode_node_delete_form_alter(&$form){
	// dsm($form, '_tode_node_delete_form_alter : form');
	#get the node
	$node = $form['#parameters'][2];
	// dsm($node);
	
	# why that tnid ???
	// if($node->tnid != 0)
	// 	return;

	#get the fields defenition of node type
	$tode_fields = _tode_get_tode_fields_def($node->type);
	//dsm($tode_fields);
	
	if(count($tode_fields) == 0)
		return;

	#get the terms value
	$terms = array();
	$tids = array();
	foreach ($tode_fields as $field_name => $field) {
		foreach ($node->$field_name as $term) {
			$term = taxonomy_get_term($term['value']);
			$terms[] = $term->name;
			$tids[] = $term->tid;
		}
	}

	if(count($terms)){
		/*
			TODO add here a checkbox to select terms to delete
		*/
		#add some warning in form description
		$form['description']['#value'] .= '<br />'.t('this will also delete taxonomy terms : %terms', array('%terms'=>implode(', ', $terms)));

		$form['tode_delete'] = array( '#type' => 'hidden', '#value' => serialize($tids),);

		$form['tode_terms'] = array('#type' => 'hidden', '#value' => serialize($terms),);

		$form['#submit'][] = 'tode_delete_submit';
	}
	


}

function tode_delete_submit($form, &$form_state){
	$tids = unserialize($form['tode_delete']['#value']);
	foreach ($tids as $tid)
		taxonomy_del_term($tid);
		
	$terms = unserialize($form['tode_terms']['#value']);	
	drupal_set_message(t('Following Taxonomy terms have been deleted : %terms', array('%terms' => implode(', ', $terms) )), 'status');
}

/**
 * HELPERS 
 */
// 
// function _tode_prefix_keys($k){
// 	if(strpos('#', $kk) == false)
// 		return $prefix.$k;
// }

function _tode_clean_form($form){
	foreach ($form as $key => $value) {
		if(strpos($key,'#') !== false){
			unset($form[$key]);			
		}elseif(is_array($value)){
			$form[$key] = _tode_clean_form($value);			
		}
	}
	return $form;
}

function _tode_prefix_form($form, $prefix = '', $add = TRUE){
	
	foreach ($form as $key => $value) {
		if(strpos($key,'#') === false){

			if($value['#type'] == 'fieldset' || (!$add && is_array($value)))
				$value = _tode_prefix_form($value, $prefix, $add);
				
			if($add){
				$form[$prefix.$key] = $value;
				unset($form[$key]);
			}elseif(strpos($key, $prefix) !== false ){
				$form[str_replace($prefix, '', $key)] = $value;
				unset($form[$key]);
			}
			
		}
	}
	
	return $form;
}

/**
 * _tode_term_form($tid)
 * 
 */
function _tode_term_form($term){
	
	if ($array_term = (array)$term) {
		
		$form_state = array();
		$term_form = drupal_retrieve_form('taxonomy_form_term', $form_state, taxonomy_vocabulary_load($array_term['vid']), $array_term);
		drupal_prepare_form('taxonomy_form_term', $term_form, $form_state);
		
		return $term_form;
	}else{
		return false;
	}
	
}

/**
 * _tode_trim_options(&$form, $element)
 * 
 */
function _tode_trim_options(&$form, $item){
	foreach ($form[$item] as $field_name => $field) {
		if(((is_array($field)) && $field['#type'] == 'select') && $field['#multiple']){
			$options = $field['#options'];
			for ($i=0; $i < count($options); $i++) { 
				if(!isset($options[$i]->option)) 
					continue;
					
				$op = array();
				foreach ($options[$i]->option as $key => $value)
						$op[$key] = strlen($value) > 25 ? substr_replace ($value, ' [...] ', 15, -10) : $value; // affiche 'abc...xyz'
						
				$options[$i]->option = $op;
			}
			$field['#options'] = $options;
			$form[$item][$field_name] = $field;
		}
	}
}

/**
 * OK OK OK
 */
function _tode_get_tode_fields_def($node){
	dsm($node, '_tode_get_fields_def');

	#get the fields defenition of node type
	$type_fields = field_info_instances('node');
	dsm($type_fields, 'type_fields definition');

	#get the tode node fields
	$tode_fields = array();
	foreach ($type_fields[$node->type] as $field_name => $field) {
		if($field['widget']['type'] == 'tode')
			$tode_fields[$field_name] = $field;
	}


	return $tode_fields;
}
