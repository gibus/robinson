<?php
/**
 * developed by www.g-u-i.net
 * 2011
 * First time this field will be used, it will create a new term with the value inserted in the textfield, 
 * after that, the term (tid) will always be the same, just update term name by updating the value of the field. 
 * You can keep synchronized a fixe term with a node, 
 * you can set an auto title from this field, The required, 
 * number of value at 1 and term_node synch of global field are required
 * 
 * 
 */

/**
 * Implementation of hook_menu().
 */
/*
function tode_menu() {
	$items = array();

	// $items['node/%node/tode/%term'] = array(
	//     'title' => 'Taxonomy Term',
	//     'type' => MENU_LOCAL_TASK,
	//     'access callback' => 'tode_node_tab_access',
	//     'access arguments' => array(2),
	//     'page callback' => 'tode_tab_page',
	//     'page arguments' => array(2),
	//     'file' => 'tode.pages.inc',
	//     'weight' => 2,
	//   );

	return $items;
}
*/

/**
 * Implements hook_views_api().
 */
/*
	TODO hook_views_api().
*/
// function tode_views_api() {
//   return array(
//     'api' => 3,
//     'path' => drupal_get_path('module', 'tode') . '/views',
//   );
// }



/**
 * Implementation of hook_theme().
 */
function tode_theme() {
	return array(
		'tode' => array(
			'arguments' => array('element' => NULL),
		),
	);
}

/**
 * Implementation of hook_init().
 */
function tode_init() {
	// File hooks and callbacks may be used by any module.
	drupal_add_css(drupal_get_path('module', 'tode') .'/tode.css');
}

/**
 * Implementation of hook_field_widget_info().
 */
function tode_field_widget_info() {
	
	return array(
    'tode' => array(
      'label' => t('Tode (create then update one unique term)'),
      'field types' => array('taxonomy_term_reference'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
				'default value' => FIELD_BEHAVIOR_NONE,
      ),
      'settings' => array(
        'size' => 60,
				'show_term_form'=> -1,
				'choose_term_parent'=> -1,
				'maxlength'=> 255,
      ),
    ),
  );
}

/**
 * Implementation of hook_widget_settings
 */
function tode_field_widget_settings_form($field, $instance){
	// dsm($instance, 'tode_field_widget_settings_form : $instance');
	// dsm($field, 'field');
	
	$widget = $instance['widget'];
  $settings = $widget['settings'];

	
		// '#description' => t('First time this field will be used, it will create a new term with the value inserted in the textfield, after that, the term (tid) will always be the same, just update term name by updating the value of the field. You can keep synchronized a fixe term with a node, you can set an auto title from this field, The required, number of value at 1 and term_node synch of global field are required')
		 
		$form['maxlength'] = array(
			'#type' => 'textfield', 
			'#title' => t('Maximum length of term'), 
			'#default_value' => $settings['maxlength'],
			'#element_validate' => array('_tode_widget_settings_maxlength_validate'),
			'#required' => TRUE,
			'#description' => t('Defines how many characters can be typed into the text field. For values higher than 255, remember that one term name can not be longer than 255 (would be cutted).'),
		);
		
		/*
			TODO complete the all flow of this
		*/
		$form['show_term_form'] = array(
			'#type' => 'checkbox',
			'#title' => t('Show taxonomy term edit form ?'),
			'#default_value' => $settings['show_term_form'],
		);

		$form['choose_term_parent'] = array(
			'#type' => 'checkbox',
			'#title' => t('Enable taxonomy term parent selection ?'),
			'#default_value' => $settings['choose_term_parent'],
		);

		return $form;
	
}

function _tode_widget_settings_maxlength_validate($element, &$form_state) {
	// dsm('_tode_widget_settings_maxlength_validate');
	// dsm($element, '$element');
	// dsm($form_state, '$form_state');
	$widget = $form_state['values']['instance']['widget'];
	$value = $widget['settings']['maxlength'];
	if (!is_numeric($value) || intval($value) != $value || $value <= 0) {
		form_error($element, t('"Maximum length" must be a positive integer.'));
	}
}

/**
 * Implementation of FAPI hook_elements().
 *
 * Any FAPI callbacks needed for individual widgets can be declared here,
 * and the element will be passed to those callbacks for processing.
 *
 * Drupal will automatically theme the element using a theme with
 * the same name as the hook_elements key.
 *
 * Autocomplete_path is not used by text_widget but other widgets can use it
 * (see nodereference and userreference).
 * 
 * http://drupal.org/node/224333#hook_element_info
 * 
 */
#hook_element_info() WHY ??
/*
function tode_element_info(){
	return array(
	 'tode' => array(
		 '#input' => TRUE,
		 '#columns' => array('value'), 
		 '#delta' => 0,
		 '#process' => array('tode_element_process'),
		 ),
	 );
}
*/

/**
 * Implementation of hook_field_widget_form().
 */
function tode_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
	// dsm('- - - - tode_field_widget_form');
	// dsm($form, '&$form');
	// dsm($form_state, '&$form_state');
	// dsm($items, 'items');
	// dsm($element, '$element');
	// dsm($field, '$field');
	// dsm($instance, '$instance');

	
	$node = $form_state['node'];
	// dsm($node, '$node');
	
	if(isset($items[$delta])){
		$term = taxonomy_term_load($items[$delta]['tid']);
		// $term = i18n_taxonomy_term_get_translation($term, $node->language); // marche pas avec localized term
		// dsm($term, '$term');
		$term_parents = taxonomy_get_parents($term->tid);
		// dsm($term_parents, '$term_parents');
		$term_parent = array_pop($term_parents);
	}
	
	# no need of $node->translation_source because with node translation (not entity fields translation) tid remains
	# just have to translate term name on submit
	// if( !isset($node->id) && isset($node->translation_source) ){
	// }
	
	$form['tode_tid'] = array('#type' => 'hidden', '#value' => isset($term) ? $term->tid : 0,'#delta' => $element['#delta'],);
	
	# parent
	if( $instance['widget']['settings']['choose_term_parent'] ){
		// add parent form autocomplete if activated		
		$vocabularies = array();
    foreach ($field['settings']['allowed_values'] as $tree)
      if ($vocabulary = taxonomy_vocabulary_machine_name_load($tree['vocabulary']))
        $vocabularies[$vocabulary->vid] = $vocabulary;

    $vocabulary = reset($vocabularies);
		// dsm($vocabulary, '$vocabulary');
		
		$form['tode_vid'] = array('#type' => 'hidden', '#value' => $vocabulary->vid,'#delta' => $element['#delta'],);
		
		$form['tode_parent_term'] = array(
			'#title' => 'Parent ' . $vocabulary->name . ' (optional)',
	    '#type' => 'textfield',
	    '#default_value' => isset($term_parent) ? $term_parent->name : '',
	    '#autocomplete_path' => 'taxonomy/autocomplete' . '/' . $field['field_name'],
	    '#size' => 60,
	    '#maxlength' => 1024,
	    '#element_validate' => array('tode_parent_autocomplete_validate'),
	  );
	
	}else{
		// if parent selection not enabled set the current parent as hidden input
		$form['tode_parent_term'] = array(
		  '#type' => 'hidden',
		  '#value' => isset($term_parent) ? $term_parent->name : '',
			'#delta' => $element['#delta'],
		);
	}
	
	// set element form item
  $element += array(
    '#type' => 'textfield',
    '#default_value' => isset($term) ? ( module_exists('i18n_taxonomy') ? i18n_taxonomy_term_name($term, $node->language) : $term->name ) : '',
    '#size' => $instance['widget']['settings']['size'],
    '#maxlength' => $instance['widget']['settings']['maxlength'],
    '#element_validate' => array('tode_widget_validate'),
    // '#element_submit' => array('tode_widget_submit'),
  );
	

	# add the term edit form
	if(isset($term))
		_tode_add_term_form($form, $term, $instance, $element['#delta']);
	
	// dsm($form, 'end tode_field_widget_form :: $form');
  return $element;
}


/**
 * _tode_add_term_form($term)
 *
 * show the complete taxonomy term form if feature is enabled
 * 
 */
function _tode_add_term_form(&$form, $term, $instance, $delta){
	// dsm('- - - - _tode_add_term_form');
	module_load_include('inc', 'taxonomy', 'taxonomy.admin');
	
	$term_form = _tode_term_form($term);
	// dsm($term_form, 'term_form');
	
	if($term_form){

		unset($term_form['actions']);
		unset($term_form['#action']);
		unset($term_form['#method']);
		
		#unset vid info 'cause is in conflict with the node's vid field
		unset($term_form['vid']);
		
		$term_form = _tode_clean_form($term_form);

		$prefix = 'tode_termform_'.$instance['field_name'];
		$term_form = _tode_prefix_form($term_form, $prefix.'_');

		$visible = $instance['widget']['settings']['show_term_form'];
				
		$form[$prefix] = array(
			'#type' => 'fieldset',
			'#title' => t('Term edit'),
			'#tree' => TRUE,
			'#collapsible' => TRUE,
			'#collapsed' => FALSE,
			'#weight'=>1,
			// '#group'=>'additional_settings',
			'#prefix' => $visible ? null : '<div style="display:none;">',
			'#suffix' => $visible ? null : '</div>',
		);
				  
		$form[$prefix] += $term_form;


		
		// $form['tode_termform'] = array('#type' => 'hidden', '#value' => 'true','#delta' => $delta,);
		
	}

}


/**
 * Form element validate handler for tode parent term autocomplete element.
 */
function tode_parent_autocomplete_validate($element, &$form_state) {
	// dsm('- - - - tode_autocomplete_validate');
	// dsm($element, '$element');
	// dsm($form_state, '$form_state');

	$value = array();
  if ($typed_term = $element['#value']) {  
   	// Translate term names into actual terms.
    // See if the term exists in the chosen vocabulary and return the tid;
    // otherwise, set error.
    if ($possibilities = taxonomy_term_load_multiple(array(), array('name' => trim($typed_term), 'vid' => $form_state['values']['tode_vid']))) {
      $term = array_pop($possibilities);
			$value = (array)$term;
    }
    else {
		form_error($element, t('Parent term can only be an existing term.'));
    }
  }
  // 
	// dsm('form_set_value');
  form_set_value($element, $value, $form_state);
}

/**
 * Validation function for the tode element
 *
 * parses input and sets the values as needed (tid) for storing the data
 */
function tode_widget_validate($element, &$form_state){
	// dsm('- - - - tode_widget_validate');
	// dsm($form_state, 'form_state');
	// dsm($element, 'element');
	
	$node = $form_state['node'];
	
	
 	$value = array();
  if ($typed_term = $element['#value']) {
		$field = field_widget_field($element, $form_state);
		// dsm($field, 'field');

    $vocabularies = array();
    foreach ($field['settings']['allowed_values'] as $tree) {
      if ($vocabulary = taxonomy_vocabulary_machine_name_load($tree['vocabulary'])) {
        $vocabularies[$vocabulary->vid] = $vocabulary;
      }
    }
		
		// get the parent term tid or 0 (no parents)
		$parent_tid = isset($form_state['values']['tode_parent_term']['tid']) ? $form_state['values']['tode_parent_term']['tid'] : 0;
		
		// See if the term already exists and load the term
    // otherwise, create a new 'autocreate' term for insert.
		if($tid = $form_state['values']['tode_tid']){
			$term = taxonomy_term_load($tid);
			
			$term->name = $typed_term;
			$term->parent = $parent_tid;
			
		}else{
			$vocabulary = reset($vocabularies);
			$term = (object)array(
        'tid' => 'autocreate', // autocreate not needed with direct taxonomy_term_save [EDIT] autocreate needed because of the hook_submit insted of hook_validate 
        'vid' => $vocabulary->vid,
        'name' => $typed_term,
        'vocabulary_machine_name' => $vocabulary->machine_name,
				'parent' => $parent_tid,
      );
			// taxonomy_term_save($term); // save here the new term to directly get the tid on hook_node_validate
			// [EDIT] do not save the term here because it will be save even if node form is not validate
			// results term without node or mutiple orfan term
			// moving all process on node submit
			
		}
		
		// dsm($term, '$term');
		$value = (array)$term;
	}
	
	// dsm($value, '$value');
  form_set_value($element, $value, $form_state);
}


/**
 * Implements hook_field_widget_error().
 */
function tode_field_widget_error($element, $error, $form, &$form_state) {
	# use this to set errors
	form_error($element['value'], $error['message']);
}


/**
 * Implements hook_node_submit().
 */
function tode_node_submit($node, $form, &$form_state) {
	// dsm('- - - tode_node_submit');
	// dsm($node, '$node');
	// dsm($form, '$form');
	// dsm($form_state, '$form_state');

	
	module_load_include('inc', 'taxonomy', 'taxonomy.admin');
	// module_load_include('inc', 'i18n_string', 'i18n_string.pages');
	// 
	$tode_fields = _tode_get_tode_fields_def($node);
	// dsm($tode_fields, '$tode_fields');
	
	
	if(!count($tode_fields))
		return;
	
	$language = $node->language;

	$default_language = language_default('language');
	// dsm($default_language, '$default_language');
	
	foreach ($tode_fields as $field_name => $field) {

		// retreive the prefixed termfom values (hidden or visible)
		$prefix = 'tode_termform_'.$field_name;
		
		// if term_form is not available
		// it meens that we are on the creation of a node
		// hook_node_presave will handle this case
		if( !isset($form_state['values'][$prefix]) )
			continue;
		
		// else
		// we are on the update or on the translation (from initial node)
		// so we can go forward
		
		// retreive the initial tode_field language
		$init_language = $form[$field_name]['#language'];

		// retreive the value of term field, to get the typed term name
		$tode_field_term_value = $form_state['values'][$field_name][$init_language][0];
		// dsm($tode_field_term_value, '$tode_field_term_value');
	
		$values = _tode_prefix_form($form_state['values'][$prefix], $prefix.'_', FALSE);
		// dsm($values, 'values');
	
		if(!module_exists('i18n_taxonomy') || $language == 'und' || $language == $default_language){
	
			// define the form_state for term_form submit
			$new_term_form_state = array(
				'build_info'=>array(
					'args'=>array(0=>(object)$tode_field_term_value),
				),
				"values"=>array(
					'name'=> $tode_field_term_value['name'], // replace the original (hidden) term name value by the typed in the the entity field
					'op'=> t('Save'),
				)
			);
			// add new values to form_state
			$new_term_form_state['values'] += $values;
	
			// dsm($new_term_form_state, 'form_state');
			drupal_form_submit('taxonomy_form_term', $new_term_form_state);
		}else{			
		
			$context= array('term',$values['tid'],'name');
		
			i18n_string_textgroup('taxonomy')->update_translation($context, $language, $tode_field_term_value['name']);
		}
		
	}
	
}



/**
 * Implements hook_node_presave().
 */
function tode_node_presave($node) {
	// dsm('- - - tode_node_presave');
	// dsm($node, 'node');
	
	if($node->nid)
		return;
	
	$tode_fields = _tode_get_tode_fields_def($node);
	
	if(!count($tode_fields))
		return;
	
	$default_language = language_default('language');

	// purpose of that is to directly atribute the right language to the term	
	foreach ($tode_fields as $field_name => $field){
		$tode_field = $node->$field_name;
		$tode_field_term = $tode_field[$node->language][0]; // on node creation field language is always to und (sure ?)

		// // test the language, if not default language create the term name translation
		if( module_exists('i18n_taxonomy') && ( $node->language != 'und' || $node->language != $default_language ) ){
			$context= array('term',$tode_field_term['tid'],'name');
			i18n_string_textgroup('taxonomy')->update_translation($context, $node->language, $tode_field_term['name']);
		}
		
	}
}


/*
	TODO Sélectionner une traduction pour test tode fr
	merge two terms when translation is made by selecting a node whiche already exists
*/




/**
 * Implementation of hook_form_alter().
 * 
 * node deletion to delete also the tode term
 * 
 */
function tode_form_alter(&$form, $form_state, $form_id){
	
	/*
		TODO block the deletion if tode term has children !! because this will delete them to …
	*/
	
	if (stripos($form_id, 'node_delete_confirm') !== false){
		// dsm($form_id, 'tode form_alter form_id');
		_tode_node_delete_form_alter($form, $form_state);
		// dsm($form);
	}else if(stripos($form_id, 'node_admin_content') !== false){
		if(isset($form['operation']) && $form['operation']['#value'] == 'delete'){
			// dsm($form, 'node_admin_content form');
			// dsm($form_state, 'form_state');
			_tode_nodes_delete_form_alter($form, $form_state);

		}
	}

}

function _tode_node_delete_form_alter(&$form, $form_state){
	// dsm($form, '_tode_node_delete_form_alter : form');
	// get the node
	$node = $form['#node'];
	// dsm($node, '$node');

	#get the fields defenition of node type
	$tode_fields = _tode_get_tode_fields_def($node);
	// dsm($tode_fields);
	
	if(count($tode_fields) == 0)
		return;

	#get the terms value
	$terms = array('names'=>array(), 'tids'=>array());
	foreach ($tode_fields as $field_name => $field)
		_tode_populate_terms_node_delete($terms, $node->$field_name);

	_tode_node_delete_prepare_form($form, $terms);
}

function _tode_nodes_delete_form_alter(&$form, $form_state){
	// dsm($form, '_tode_nodes_delete_form_alter : form');
	$nodes = array();
	foreach ($form_state['values']['nodes'] as $nid => $actif)
		if($actif)
			$nodes[] = node_load($nid);

	#get the terms value
	$terms = array('names'=>array(), 'tids'=>array());
	foreach ($nodes as $node) {
		#get the fields definition of node type
		$tode_fields = _tode_get_tode_fields_def($node);
		//dsm($tode_fields);
		
		if(count($tode_fields) == 0)
			continue;

		foreach ($tode_fields as $field_name => $field)
			_tode_populate_terms_node_delete($terms, $node->$field_name);
			
	}

	_tode_node_delete_prepare_form($form, $terms);
}

function _tode_populate_terms_node_delete(&$terms, $tode_field){
	foreach ($tode_field as $language) {
		foreach ($language as $term) {
			$term = taxonomy_term_load($term['tid']);
			if(isset($term->tid) && !in_array($term->tid, $terms['tids'])){
				$terms['names'][] = $term->name;
				$terms['tids'][] = $term->tid;
			}
		}
	}
}

function _tode_node_delete_prepare_form(&$form, $terms){

	if(count($terms)){
		/*
			TODO add here a checkbox to select terms to delete
		*/
		#add some warning in form description
		$form['description']['#markup'] .= '<br />'.t('this will also delete taxonomy terms : %terms', array('%terms'=>implode(', ', $terms['names'])));

		$form['tode_delete'] = array( '#type' => 'hidden', '#value' => serialize($terms['tids']),);

		$form['tode_terms'] = array('#type' => 'hidden', '#value' => serialize($terms['names']),);

		$form['#submit'][] = 'tode_delete_submit';
	}
	
	
}

function tode_delete_submit($form, &$form_state){
	$tids = unserialize($form['tode_delete']['#value']);
	foreach ($tids as $tid)
		taxonomy_term_delete($tid);
		
	$terms = unserialize($form['tode_terms']['#value']);	
	drupal_set_message(t('Following Taxonomy terms have been deleted : %terms', array('%terms' => implode(', ', $terms) )), 'status');
}

/**
 * HELPERS 
 */
function _tode_clean_form($form, $level = 0){
	foreach ($form as $key => $value) {
		if(strpos($key,'#') !== false || $key == 'form_build_id' || $key == 'form_id' || $key == 'form_token'){
			if( $level == 0 || $key == "#element_validate")
				unset($form[$key]);
		}elseif(is_array($value)){
			$form[$key] = _tode_clean_form($value, $level+1);			
		}
	}
	return $form;
}

function _tode_prefix_form($form, $prefix = '', $add = TRUE){
	
	foreach ($form as $key => $value) {
		if(strpos($key,'#') === false){

			if((isset($value['#type']) && $value['#type'] == 'fieldset') || (!$add && is_array($value)))
				$value = _tode_prefix_form($value, $prefix, $add);
				
			if($add){
				$form[$prefix.$key] = $value;
				unset($form[$key]);
			}elseif(strpos($key, $prefix) !== false ){
				$form[str_replace($prefix, '', $key)] = $value;
				unset($form[$key]);
			}
			
		}
	}
	
	return $form;
}

/**
 * _tode_term_form($tid)
 * 
 */
function _tode_term_form($term){
	// dsm('_tode_term_form');
	if ($term) {
		
		$form_state = array(
			'build_info'=>array(
				'args'=>array(0=>$term)
			),
			'method'=>'post',
		);

		// function taxonomy_form_term($form, &$form_state, $edit = array(), $vocabulary = NULL) {
		$term_form = drupal_retrieve_form('taxonomy_form_term', $form_state);
		drupal_prepare_form('taxonomy_form_term', $term_form, $form_state);
		
		return $term_form;
	}else{
		return false;
	}
	
}

/**
 * _tode_trim_options(&$form, $element)
 * 
 */
function _tode_trim_options(&$form, $item){
	foreach ($form[$item] as $field_name => $field) {
		if(((is_array($field)) && $field['#type'] == 'select') && $field['#multiple']){
			$options = $field['#options'];
			for ($i=0; $i < count($options); $i++) { 
				if(!isset($options[$i]->option)) 
					continue;
					
				$op = array();
				foreach ($options[$i]->option as $key => $value)
						$op[$key] = strlen($value) > 25 ? substr_replace ($value, ' [...] ', 15, -10) : $value; // affiche 'abc...xyz'
						
				$options[$i]->option = $op;
			}
			$field['#options'] = $options;
			$form[$item][$field_name] = $field;
		}
	}
}

/**
 * OK OK OK
 */
function _tode_get_tode_fields_def($node){
	// dsm($node, '_tode_get_fields_def');

	#get the fields defenition of node type
	$type_fields = field_info_instances('node');
	// dsm($type_fields, 'type_fields definition');

	#get the tode node fields
	$tode_fields = array();
	foreach ($type_fields[$node->type] as $field_name => $field) {
		if($field['widget']['type'] == 'tode')
			$tode_fields[$field_name] = $field;
	}


	return $tode_fields;
}


