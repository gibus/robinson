<?php
// $Id$

/**
 * @file
 * Creates a simplemenu.
 */

/**
 * Implementation of hook_menu().
 */
function simplemenu_menu() {
  $items = array();

  $items['admin/settings/simplemenu'] = array(
    'title' => 'SimpleMenu',
    'description' => 'Select the menu to display.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('simplemenu_admin_settings'),
    'access arguments' => array('administer simplemenu'),
    'file' => 'simplemenu.admin.inc',
  );

  return $items;
}

/**
 * Is simplemenu enabled for this page request?
 */
function simplemenu_enabled() {
  static $enabled;

  if (!isset($enabled)) {
    global $theme;
    $exclusions = variable_get('simplemenu_exclusions', array());
    $enabled = (user_access('view simplemenu')
      && (!isset($exclusions[$theme]) || !$exclusions[$theme])
      && _simplemenu_page_visibility()
      && _simplemenu_superuser_active());
  }

  return $enabled;
}

/**
 * Implementation of hook_init().
 */
function simplemenu_init() {
  // do a simple access check here, since theme isn't available to check yet
  if (user_access('view simplemenu') && simplemenu_enabled()) {
    $simplemenu_path = drupal_get_path('module', 'simplemenu');
    $css_path = file_create_path('css'); // same path as concatenated Core CSS
    if (file_check_directory($css_path, FILE_CREATE_DIRECTORY)) {
      // The old way had a "static" CSS which meant that we could not easily
      // offer options to the users.
      //drupal_add_css($simplemenu_path .'/simplemenu.css');

      $fix = variable_get('simplemenu_fix', 'scroll');

      // XXX add a variable simplemenu_update which is set to TRUE whenever
      //     the settings get modified and false here
      $output_filename = variable_get('simplemenu_css_filename', '');
      if (!$output_filename) {
        $tags = array(
          '@MENUBAR_ZINDEX@' => simplemnu_get_zindex('simplemenu_menubar_zindex', 9999),
          '@DROPDOWN_ZINDEX@' => simplemnu_get_zindex('simplemenu_dropdown_zindex', 9999),
        );
        switch ($fix) {
        case 'top':
          $tags['@FIX@'] = "position: fixed;\n  top: 0;";
          break;

        case 'bottom':
          $tags['@FIX@'] = "position: fixed;\n  bottom: 0;";
          break;

        default: // scroll
          $tags['@FIX@'] = 'position: relative;';
          break;

        }
        $css = file_get_contents($simplemenu_path . '/simplemenu.css.tpl');
        $css = strtr($css, $tags);
        $css_md5 = md5($css);
        $output_filename = $css_path . '/simplemenu-' . $css_md5 . '.css';
        if (!file_exists($output_filename)) {
          // new content, create a new file
          file_put_contents($output_filename, $css);
        }
        else {
          // this call is rather ugly, but we must make sure that the
          // system cache will take the current Simplemenu CSS in account
          _drupal_flush_css_js();
        }
        //variable_set('simplemenu_css_filename', $output_filename);
      }
      drupal_add_css($output_filename);
    }
    else {
      drupal_set_message(t('Simplemenu could not create the folder @path in order to save the dynamic CSS data.',
        array('@path' => $css_path)), 'error');

      // use a default that cannot react to the dynamic changes...
      drupal_add_css($simplemenu_path .'/simplemenu.css');
    }

    // we want to put the simplemenu theme CSS first
    // so we can change some CSS entries dynamically
    // but at this time the simplemenu.css is used to
    // reset many of the CSS entries... Hmmm...
    $simplemenu_theme = variable_get('simplemenu_theme', 'original');
    $theme_file = $simplemenu_path .'/themes/'. $simplemenu_theme .'/'. $simplemenu_theme .'.css';
    if (is_file($theme_file)) {
      drupal_add_css($theme_file);
    }

    switch ($fix) {
    case 'top':
      $element = 'body';
      $placement = 'prepend';
      break;

    case 'bottom':
      $element = 'body';
      $placement = 'append';
      break;

    default: // 'scroll'
      // let user defined other elements when not fixed
      $element = variable_get('simplemenu_element', 'body');
      $placement = variable_get('simplemenu_element_method', 'prepend');
      break;

    }

    $settings = array(
      'effect' => variable_get('simplemenu_effect', 'opacity'),
      'effectSpeed' => variable_get('simplemenu_effect_speed', 'fast'),
      'element' => $element,
      'placement' => $placement,
      'hideDelay' => variable_get('simplemenu_hide_delay', 800),
      'detectPopup' => variable_get('simplemenu_detect_popup', 1),
    );

    drupal_add_js(array('simplemenu' => $settings), 'setting');
    drupal_add_js($simplemenu_path . '/simplemenu.js');
    $superfish = variable_get('simplemenu_superfish_version', 'superfish-1.4.1.js');
    drupal_add_js($simplemenu_path . '/' . $superfish);
  }
}

/**
 * \brief Retrieve the zindex for the CSS files.
 *
 * This function retrieves a z-index from a Drupal variable and
 * transform it to fit in a CSS file.
 *
 * \param[in] $name The name of the z-index variable to read.
 * \param[in] $default The default value to use when the variable is not defined.
 *
 * \return A string representing the current value of the specified z-index.
 */
function simplemnu_get_zindex($name, $default) {
  $zindex = variable_get($name, $default);

  if ($zindex == -1) {
    $zindex = '';
  }
  else {
    $zindex = 'z-index: ' . $zindex . ';';
  }

  return $zindex;
}

/**
 * Implementation of hook_footer().
 *
 * This has been broken off of simplemenu_init() because simplemenu_get_menu()
 * calls simplemenu_menu_tree() which calls menu_tree_output() which has several
 * calls to theme().  This initializes the theme system too early causing hard
 * to track bugs.
 *
 * @see http://drupal.org/node/219910
 */
function simplemenu_footer() {
  if (simplemenu_enabled()) {
    $simplemenu = drupal_to_js(simplemenu_get_menu());
    $path = base_path() . drupal_get_path('module', 'simplemenu');

    $output = "<script type=\"text/javascript\">var simplemenu = $simplemenu;</script>\n";

    return $output;
  }
}

/**
 * Implementation of hook_perm().
 */
function simplemenu_perm() {
  return array('view simplemenu', 'administer simplemenu');
}

/**
 * Render an HTML list of links for a given menu.
 */
function simplemenu_get_menu() {
  // if a user turned off menu module but SimpleMenu was previously set
  // reset variable so a menu appears
  $menu_name = module_exists('menu') ? variable_get('simplemenu_menu', 'navigation:0') : 'navigation:0';
  $menu = simplemenu_menu_tree($menu_name);

  if (!$menu) {
    $menu = '<ul class="menu"><li><a href="'. url('admin/settings/simplemenu') .'">'. t('No menu items found. Try a different menu as the default.') .'</a></li></ul>';
  }

  // This is ugly, I know, but it is the only way I can see to get the additional
  // links inside the <ul> tags
  if ($devel = simplemenu_get_devel()) {
    $pos = strpos($menu, '>') + 1;
    $menu = substr($menu, 0, $pos) . $devel . substr($menu, $pos);
  }

  // add the class & id to the UL tag here instead of the JavaScript
  // otherwise it could be added to the <div> tag instead...
  $pos = strpos($menu, '>') + 1;
  $menu = '<ul class="menu clear-block" id="simplemenu">' . substr($menu, $pos);

  return '<div class="simplemenu-block">' . $menu . '&nbsp;</div>';
}

/**
 * Custom implementation of menu_tree().
 * We want to retrieve the entire menu structure for a given menu,
 * regardless of whether or not the menu item is expanded or not.
 */

function simplemenu_menu_tree($menu_name = 'navigation:0') {
  static $menu_output = array();

  if (!isset($menu_output[$menu_name])) {
    $tree = simplemenu_tree_all_data($menu_name);
    $menu_output[$menu_name] = menu_tree_output($tree);
  }
  return $menu_output[$menu_name];
}

/**
 * Modified menu_tree_all_data(), providing the complete menu tree below $root_menu
 * (which can be *any* menu item, not just the root of a custom menu).
 *
 * @param $root_menu
 *   root menu item of the tree to return as "menu_name:mlid" (mlid = menu link id)
 *
 * @todo we don't actually need $menu_name, $mlid would be sufficient
 */
function simplemenu_tree_all_data($root_menu = 'navigation:0') {
  static $tree = array();

  list($menu_name, $mlid) = explode(':', $root_menu);

  // Generate the cache ID.
  // "links:navigation:all:2" means "all from root to 2" (what the ...), so for "all from 2 down" we do "links:navigation:all:2:all"
  $cid = "links:$menu_name:all:$mlid". ($mlid ? ':all' : '');

  if (!isset($tree[$cid])) {
    // If the static variable doesn't have the data, check {cache_menu}.
    $cache = cache_get($cid, 'cache_menu');
    if ($cache && isset($cache->data)) {
      $data = $cache->data;
    }
    else {
      // Build and run the query, and build the tree.
      if ($mlid > 0) {
        $item = menu_link_load($mlid);
        // The tree is a subtree of $menu_name, so we need to restrict the query to
        // this subtree.
        $px = "p$item[depth]";
        $where = " AND ml.$px = %d AND ml.mlid != %d";
        $args = array($item[$px], $mlid);
      }
      else {
        // Get all links in this menu.
        $where = '';
        $args = array();
      }
      array_unshift($args, $menu_name);
      // Select the links from the table, and recursively build the tree.  We
      // LEFT JOIN since there is no match in {menu_router} for an external
      // link.
      $data['tree'] = menu_tree_data(db_query("
        SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, m.description, ml.*
        FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path
        WHERE ml.menu_name = '%s'". $where ."
        ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC", $args));
      $data['node_links'] = array();
      menu_tree_collect_node_links($data['tree'], $data['node_links']);
      // Cache the data.
      cache_set($cid, $data, 'cache_menu');
    }
    // Check access for the current user to each item in the tree.
    menu_tree_check_access($data['tree'], $data['node_links']);
    $tree[$cid] = $data['tree'];
  }

  return $tree[$cid];
}

/**
 * Return a list of devel module links if the module is enabled
 * and the user has access to this module.
 */
function simplemenu_get_devel() {
  $output = '';

  if (variable_get('simplemenu_devel', 0) && module_exists('devel')) {
    if (user_access('access devel information')) {
      $output = '<li class="expanded"><a href="'. url('admin/settings/devel') .'">'. t('Devel module') .'</a>';
      $output .= simplemenu_menu_tree('devel');
      $output .= '</li>';
    }
  }

  return $output;
}

/**
 * Determine if simplemenu should be displayed based on visibility settings.
 *
 * @return boolean
 */
function _simplemenu_page_visibility() {
  $operator = variable_get('simplemenu_visibility_operator', 0);
  $pages = variable_get('simplemenu_visibility_pages', '');

  if ($pages) {
    $path = drupal_get_path_alias($_GET['q']);
    // Compare with the internal and path alias (if any).
    $page_match = drupal_match_path($path, $pages);
    if ($path != $_GET['q']) {
      $page_match = $page_match || drupal_match_path($_GET['q'], $pages);
    }
    // When $operator has a value of 0, the menu is displayed on
    // all pages except those listed in $pages. When set to 1, it
    // is displayed only on those pages listed in $pages.
    $page_match = !($operator ^ $page_match);
  }
  else {
    $page_match = TRUE;
  }

  return $page_match;
}

/**
 * Check whether the superuser/admin should be shown simplemenu.
 */
function _simplemenu_superuser_active() {
  global $user;
  return $user->uid != 1 || variable_get('simplemenu_uid1', 1) == 1;
}

// vim: ts=2 sw=2 et syntax=php
