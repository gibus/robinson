<?php
/**
 * @file
 * Module file providing the "corresponding entity reference" module main
 * functions.
 */

/**
 * Implements hook_menu().
 */
function corresponding_entity_references_menu() {
  $items = array();
  $items['admin/config/system/corresponding_entity_references'] = array(
    'title' => 'Corresponding entity references',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('corresponding_entity_references_settings_form'),
    'access arguments' => array('administer corresponding entity references settings'),
    'file' => 'corresponding_entity_references.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/config/system/corresponding_entity_references/references'] = array(
    'title' => 'Corresponding entity references',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('corresponding_entity_references_settings_form'),
    'access arguments' => array('administer corresponding entity references settings'),
    'file' => 'corresponding_entity_references.admin.inc',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/config/system/corresponding_entity_references/update'] = array(
    'title' => 'Update existing entities',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('corresponding_entity_references_update_form'),
    'access arguments' => array('administer corresponding entity references settings'),
    'file' => 'corresponding_entity_references.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function corresponding_entity_references_permission() {
  return array(
    'administer corresponding entity references settings' => array(
      'title' => t('Administer corresponding entity reference settings'),
      'description' => t('Administer corresponding entity reference settings'),
    )
  );
}

/**
 * Formats a label.
 */
function corresponding_entity_references_format_label($key) {
  $key = explode(' ', $key);
  return t('Field instance:"!field1" on Entity type:"!entity1" - Bundle type:"!bundle1" <b>Corresponds with</b> Field instance:"!field2" on Entity type:"!entity2" Bundle type:"!bundle2"',
    array('!entity1' => $key[0], '!bundle1' => $key[1], '!field1' => $key[2], '!entity2' => $key[3], '!bundle2' => $key[4], '!field2' => $key[5]));
}

/**
 * Implements hook_entity_insert().
 */
function corresponding_entity_references_entity_insert($entity, $type) {
  corresponding_entity_references_processing_entity('insert', $entity, $type);
}

/**
 * Implements hook_entity_update().
 */
function corresponding_entity_references_entity_update($entity, $type) {
  corresponding_entity_references_processing_entity('update', $entity, $type);
}

/**
 * Implements hook_entity_delete().
 */
function corresponding_entity_references_entity_delete($entity, $type) {
  corresponding_entity_references_processing_entity('delete', $entity, $type);
}

/**
 * Load enabled CNR presets.
 */
function corresponding_entity_references_preset_load_enabled() {
  ctools_include('export');
  return ctools_export_load_object('corresponding_entity_references', 'conditions', array('enabled' => 1));
}

/**
 * Return CNR preset by key.
 */
function corresponding_entity_references_preset_load($key) {
  ctools_include('export');
  return ctools_export_crud_load('corresponding_entity_references', $key);
}

/**
 * Return 1 if CNR preset specified by given key is enabled.
 */
function corresponding_entity_references_preset_enabled($key) {
  $preset = corresponding_entity_references_preset_load($key);
  return empty($preset) ? 0 : $preset->enabled;
}

/**
 * Process a entity's corresponding entity references.
 *
 * @param $op the operation being performed on the entity.
 * @param $entity the entity object
 * @param $process_unchanged whether or not to process entity reference fields
 *        whose values have not changed.
 */
function corresponding_entity_references_processing_entity($op, $entity, $type, $process_unchanged = FALSE) { 
  module_load_include('inc', 'corresponding_entity_references', 'corresponding_entity_references.crud');

  $result = corresponding_entity_references_preset_load_enabled();

  while ($row = array_shift($result)) {
    $key = explode('*', $row->entity_types_content_fields);
    if(($type == $key[0]) || ($type == $key[3])){
	
      $entity->home = _corresponding_entity_references_entity_get_bundle($entity, $type);

      switch ($entity->home) {
        case $key[1]:
          // Create an array to pass to op function instead of 6 arguments.
          $keys = array(
            'home_entity_type' => $key[0],
            'home_bundle' => $key[1], 
            'home_field' => $key[2],
            'away_entity_type' => $key[3],
            'away_bundle' => $key[4],
            'away_field' => $key[5],
          );
          $args = array($entity, $keys, $process_unchanged);
          $function = 'corresponding_entity_references_' . $op;
          call_user_func_array($function, $args);
          if ($key[0] != $key[2]) {
            break;
          }

        // Fall through.
        case $key[4]:
          $keys = array(
            'home_entity_type' => $key[3],
            'home_bundle' => $key[4], 
            'home_field' => $key[5],
            'away_entity_type' => $key[0],
            'away_bundle' => $key[1],
            'away_field' => $key[2],
          );
          $args = array($entity, $keys, $process_unchanged);
          $function = 'corresponding_entity_references_' . $op;
          call_user_func_array($function, $args);
          break;
      }
    }
  }
}



/**
 * Submit a batch job to index the remaining, unindexed content.
 */
function corresponding_entity_references_batch_index_remaining($types, $limit) {
  $batch = array(
    'operations' => array(
      array(
        'corresponding_entity_references_batch_update_existing_entities',
        array($types, $limit)
      ),
    ),
    'finished' => 'corresponding_entity_references_batch_update_existing_finished',
    'title' => t('Processing'),
    'init_message' => t('Preparing to update corresponding entity references for existing entities...'),
    'progress_message' => t('Processing entities...'),
    'error_message' => t('Corresponding entity references - existing entity update has encountered an error.'),
  );
  batch_set($batch);
}

/**
 * Batch Operation Callback
 *
 * @see corresponding_entity_references_batch_index_remaining()
 */
function corresponding_entity_references_batch_update_existing_entities($types, $limit, &$context) {
  // If we are on our first time through.
  if (!isset($context['sandbox']['progress'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current_entity'] = 0;
    $context['sandbox']['max'] = db_query("SELECT COUNT(DISTINCT nid) FROM {node} WHERE type IN (:types)", array(':types' => $types))->fetchField();
  }

  $nids = array();
  $args = $types;
  $args['current_entity'] = $context['sandbox']['current_entity'];
  // Get entity IDs to update.
  $result = db_query_range("SELECT nid FROM {node} WHERE type IN (:types) AND nid > :args ORDER BY nid", 0, $limit, array(':types' => $types, ':args' => $args['current_entity']));

  while ($row = $result->fetchObject()) {
    $entity = entity_load($row->nid);
    corresponding_entity_references_processing_entity('update', $entity, $type, TRUE);

    // Update our progress information.
    $context['sandbox']['progress']++;
    $context['sandbox']['current_entity'] = $entity->nid;
    $context['message'] = t('Processed @current of @total entitys', array('@current' => $context['sandbox']['progress'], '@total' => $context['sandbox']['max']));
  }

  // Inform the batch engine that we are not finished,
  // and provide an estimation of the completion level we reached.
  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
  // Put the total into the results section when we're finished so we can show
  // it to the admin.
  if ($context['finished']) {
    $context['results']['count'] = $context['sandbox']['progress'];
  }
}

/**
 * Batch 'finished' callback.
 *
 * @see corresponding_entity_references_batch_index_remaining()
 */
function corresponding_entity_references_batch_update_existing_finished($success, $results, $operations) {
  if ($success) {
    $type = 'status';
    $message = format_plural($results['count'], '1 entity processed successfully.', '@count entitys processed successfully.');
  }
  else {
    $type = 'error';
    // An error occurred.
    // $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    $message = 'An error occurred while processing ' . $error_operation[0] . ' with arguments:' . print_r($error_operation[0], TRUE);
  }
  drupal_set_message($message, $type);
}

function corresponding_entity_references_ctools_plugin_api($owner, $api) {
  if ($owner == 'corresponding_entity_references' && $api == 'default_corresponding_entity_references_presets') {
    return array('version' => 1);
  }
}